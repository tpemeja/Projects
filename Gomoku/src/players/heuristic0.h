/**
* @file heuristic0.h
*/
#ifndef HEURISTIC0_H
#define HEURISTIC0_H

#include "matrix.h"

/**
* @brief Heuristic with 2 matrix (one for the player and the other one for the\
opponent) which computes all potentials moves for the player (opportunities)\
and computes them for the opponent (dangers) and either play for the best\
move possible or counter moves of the opponent
*/
struct player{
  /**
  * size of the board
  */
  size_t size;
  /**
  * color of the player (id)
  */
  int color;
  /**
  * matrix containing all possible rows that are opportunities for the player (filled with positive or -1 values)
  */
  struct matrix * opportunity;
  /**
  * matrix containing all enemy possible rows that are dangers for the player (filled with positive or -1 values)
  */
  struct matrix * danger;
  /**
  * current board
  */
  struct matrix * actual_board;
  /**
  * number of moves already played during the game
  */
  size_t nb_moves;
};

/**
* @brief Return the difference between the 2 matrixes of opportunities and dangers to get the evaluation of the game
* @param[in] opp matrix of opportunities for the player
* @param[in] dan matrix of dangers for the player
* @return int value of the current board which help to choose the best board that will be played
*/
int heuristic_eval_game(struct matrix * opp, struct matrix* dan);

/**
* @brief Computes the length of the max possible lines in direction (di,dj) and (-di,-dj).
* @param[in] i row of the board
* @param[in] j column of the board
* @param[in] di delta for the direction for rows
* @param[in] dj delta for the direction for columns
* @return the maximum length of possible lines in direction
*/
int size_line(int i, int j, int di, int dj, int color);

/**
* @brief Explore the line from position (i,j) in the direction (di,dj) and return the strength of the line to be filled by the player
* @param[in] i row of the board
* @param[in] j column of the board
* @param[in] di direction in row from i
* @param[in] dj direction in column from j
* @param[in] color id of the player
* @return int corresponding to the strength of the line from (i,j) in the direction
*/
int explore_line(int i, int j, int di, int dj, int color);

/**
* @brief Evualate a point on the board by exploring the 8 possible directions around it and returning the max strength
* @param[in] i row of the board
* @param[in] j row of the board
* @param[in] color id of the player
* @return int corresponding to the max strength of 8 possible directions around the point
*/
int evaluate_point(int i, int j, int color);

/**
* @brief Update the matrix given in parameter with the evaluation of the points that form a star from (i,j). The heuristic's board need to be updated before
* @param[in] i row of the board
* @param[in] j column of the board
* @param[in/out] m matrix that will be updated with all strengths
* @param[in] color id of the player
* @return
*/
void update_potential_lines(int i, int j, struct matrix * m, int color);

/**
* @brief Update a single point of the board (matrix) with its evaluation
* @param[in/out] m matrix
* @param[in] i row of the board
* @param[in] j column of the board
* @param[in] color id of the player
* @return updated matrix with the strength on the point added
*/
void update_potential_lines_point(struct matrix * m, int i, int j, int color);

/**
* @brief Extract the best moves from the matrix of opportunities and matrix of dangers (with the maximum evaluation) and return the list of best moves for the player that are better for us (opportunities) than for the opponent (dangers)
* @param[in] opp matrix of opportunities for the player
* @param[in] dan matrix of dangers for the player
* @return list of moves generated by chosing the best one by taking into account both matrix of opportunities and dangers
*/
struct list * generating_moves(struct matrix * opp, struct matrix * dan);

/**
* @brief Update the heuristic's board and 2 matrixes with the move given in parameter
* @param[in] m move that will be added to the board
* @param[in] color id of the player
* @return self board of the heuristic actualized with the new move added
*/
void heuristic_actualize(struct move_t m, int color);

/**
* @brief Undo what was done by heuristic_actualize by removing a move from the heuristic board
* @param[in] mv move that will be removed from the heuristic's board
* @return heuristic's board updated without the move just removed
*/
void heuristic_remove(struct move_t mv);

/**
* @brief Verify if the player can move again or not
* @return 1 if the heuristic's board is full, 0 otherwise
*/
int heuristic_full();


#endif
